{"version":3,"mappings":"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","names":["STORAGE_KEY","async","getTauriInvoke","window","import","__VITE_PRELOAD__","url","invoke","tokenManager","constructor","__publicField","this","initialize","catch","err","stored","accessToken","refreshToken","expiresAt","Date","getTime","localStorage","getItem","data","JSON","parse","setTokens","setItem","stringify","clearTokens","removeItem","getAccessToken","now","getRefreshToken","isAuthenticated","isExpiringSoon","LRUCache","options","cache","Map","maxSize","ttl","get","key","entry","delete","misses","set","hits","value","customTtl","has","size","firstKey","keys","next","clear","prune","pruned","entries","getStats","getHitRate","total","Array","from","generateCacheKey","endpoint","params","userId","parts","sortedParams","Object","sort","map","join","push","staleWhileRevalidate","fetchFn","onRevalidate","cached","then","fresh","error","skillsCache","userCache","forgeAgentsClient","baseUrl","retryFetch","operation","context","lastError","attempt","maxRetries","appError","classifyError","shouldRetry","delay","getRetryDelay","Promise","resolve","setTimeout","createNetworkError","fetchWithTimeout","controller","AbortController","timeoutId","abort","timeout","startTime","response","fetch","signal","name","clearTimeout","login","email","password","method","headers","body","ok","json","access_token","refresh_token","expires_at","logout","getAuthHeaders","refreshAccessToken","refreshPromise","_performRefresh","Error","listSkills","cacheKey","skipCache","authenticatedFetch","getSkill","skillId","searchSkills","query","encodeURIComponent","invokeSkill","request","invokeSkillStreaming","reader","getReader","decoder","TextDecoder","buffer","done","read","trim","lines","split","line","trimmed","startsWith","jsonStr","substring","parsed","token","type","metadata","e","decode","stream","pop","releaseLock","getAuthToken","Authorization","path","status","retryResponse","createAuthenticationError"],"ignoreList":[],"sources":["../../../../../../src/lib/api/auth.ts","../../../../../../src/lib/utils/cache.ts","../../../../../../src/lib/api/forgeAgentsClient.ts"],"sourcesContent":["const STORAGE_KEY = 'forge_auth_tokens';\n\n// Check if we're running in Tauri (desktop) or browser\nfunction isTauriEnvironment(): boolean {\n\treturn typeof window !== 'undefined' && '__TAURI__' in window;\n}\n\n// Lazy load Tauri invoke function\nasync function getTauriInvoke() {\n\tif (isTauriEnvironment()) {\n\t\ttry {\n\t\t\tconst tauriCore = await import('@tauri-apps/api/core');\n\t\t\treturn tauriCore.invoke;\n\t\t} catch {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n\nexport class TokenManager {\n\tprivate accessToken: string | null = null;\n\tprivate refreshToken: string | null = null;\n\tprivate expiresAt: number | null = null;\n\n\tconstructor() {\n\t\t// Auto-initialize on construction\n\t\tthis.initialize().catch((err) => console.warn('TokenManager init failed:', err));\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\ttry {\n\t\t\t// Only run in browser environment\n\t\t\tif (typeof window === 'undefined') return;\n\n\t\t\tconst invoke = await getTauriInvoke();\n\t\t\tif (invoke) {\n\t\t\t\t// Tauri desktop app - use secure storage\n\t\t\t\tconst stored = await invoke<{\n\t\t\t\t\taccessToken: string;\n\t\t\t\t\trefreshToken: string;\n\t\t\t\t\texpiresAt: string;\n\t\t\t\t} | null>('load_tokens');\n\t\t\t\tif (stored) {\n\t\t\t\t\tthis.accessToken = stored.accessToken;\n\t\t\t\t\tthis.refreshToken = stored.refreshToken;\n\t\t\t\t\tthis.expiresAt = new Date(stored.expiresAt).getTime();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Browser - use localStorage\n\t\t\t\tconst stored = localStorage.getItem(STORAGE_KEY);\n\t\t\t\tif (stored) {\n\t\t\t\t\tconst data = JSON.parse(stored);\n\t\t\t\t\tthis.accessToken = data.accessToken;\n\t\t\t\t\tthis.refreshToken = data.refreshToken;\n\t\t\t\t\tthis.expiresAt = new Date(data.expiresAt).getTime();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.warn('Token load failed:', err);\n\t\t}\n\t}\n\n\tasync setTokens(\n\t\taccessToken: string,\n\t\trefreshToken: string,\n\t\texpiresAt: string\n\t): Promise<void> {\n\t\tthis.accessToken = accessToken;\n\t\tthis.refreshToken = refreshToken;\n\t\tthis.expiresAt = new Date(expiresAt).getTime();\n\n\t\t// Only persist in browser environment\n\t\tif (typeof window === 'undefined') return;\n\n\t\ttry {\n\t\t\tconst invoke = await getTauriInvoke();\n\t\t\tif (invoke) {\n\t\t\t\t// Tauri desktop app - use secure storage\n\t\t\t\tawait invoke('save_tokens', { accessToken, refreshToken, expiresAt });\n\t\t\t} else {\n\t\t\t\t// Browser - use localStorage\n\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\tSTORAGE_KEY,\n\t\t\t\t\tJSON.stringify({ accessToken, refreshToken, expiresAt })\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('Token save failed:', err);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync clearTokens(): Promise<void> {\n\t\tthis.accessToken = null;\n\t\tthis.refreshToken = null;\n\t\tthis.expiresAt = null;\n\n\t\t// Only persist in browser environment\n\t\tif (typeof window === 'undefined') return;\n\n\t\ttry {\n\t\t\tconst invoke = await getTauriInvoke();\n\t\t\tif (invoke) {\n\t\t\t\t// Tauri desktop app\n\t\t\t\tawait invoke('clear_tokens');\n\t\t\t} else {\n\t\t\t\t// Browser\n\t\t\t\tlocalStorage.removeItem(STORAGE_KEY);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.warn('Token clear failed:', err);\n\t\t}\n\t}\n\n\tgetAccessToken(): string | null {\n\t\tif (this.expiresAt && Date.now() >= this.expiresAt - 60000) return null;\n\t\treturn this.accessToken;\n\t}\n\n\tgetRefreshToken(): string | null {\n\t\treturn this.refreshToken;\n\t}\n\n\tisAuthenticated(): boolean {\n\t\treturn !!this.getAccessToken();\n\t}\n\n\tisExpiringSoon(): boolean {\n\t\tif (!this.expiresAt) return true;\n\t\treturn Date.now() >= this.expiresAt - 300000;\n\t}\n}\n\nexport const tokenManager = new TokenManager();\n","/**\n * LRU Cache Implementation\n *\n * Least Recently Used (LRU) cache for in-memory caching of API responses.\n * Automatically evicts least recently used entries when max size is reached.\n *\n * Features:\n * - Generic type support for any cached value\n * - TTL (time-to-live) per entry\n * - Automatic eviction of expired entries\n * - Size-based eviction (LRU algorithm)\n * - Cache statistics (hits, misses, size)\n *\n * Usage:\n * ```typescript\n * const cache = new LRUCache<User>({ maxSize: 100, ttl: 5 * 60 * 1000 });\n * cache.set('user:123', userData);\n * const user = cache.get('user:123'); // Returns userData or null if expired/missing\n * ```\n */\n\nexport interface CacheEntry<T> {\n\tvalue: T;\n\texpiresAt: number;\n}\n\nexport interface CacheOptions {\n\tmaxSize?: number; // Maximum number of entries (default: 100)\n\tttl?: number; // Time to live in milliseconds (default: 5 minutes)\n}\n\nexport interface CacheStats {\n\thits: number;\n\tmisses: number;\n\tsize: number;\n\tmaxSize: number;\n}\n\nexport class LRUCache<T> {\n\tprivate cache: Map<string, CacheEntry<T>>;\n\tprivate maxSize: number;\n\tprivate ttl: number;\n\tprivate hits: number = 0;\n\tprivate misses: number = 0;\n\n\tconstructor(options: CacheOptions = {}) {\n\t\tthis.cache = new Map();\n\t\tthis.maxSize = options.maxSize ?? 100;\n\t\tthis.ttl = options.ttl ?? 5 * 60 * 1000; // Default 5 minutes\n\t}\n\n\t/**\n\t * Get a value from the cache\n\t * Returns null if key doesn't exist or entry has expired\n\t */\n\tget(key: string): T | null {\n\t\tconst entry = this.cache.get(key);\n\n\t\tif (!entry) {\n\t\t\tthis.misses++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if expired\n\t\tif (Date.now() > entry.expiresAt) {\n\t\t\tthis.cache.delete(key);\n\t\t\tthis.misses++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Move to end (most recently used)\n\t\tthis.cache.delete(key);\n\t\tthis.cache.set(key, entry);\n\n\t\tthis.hits++;\n\t\treturn entry.value;\n\t}\n\n\t/**\n\t * Set a value in the cache\n\t * If cache is full, removes the least recently used entry\n\t */\n\tset(key: string, value: T, customTtl?: number): void {\n\t\t// If key already exists, delete it first to update position\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.delete(key);\n\t\t}\n\n\t\t// Evict LRU entry if at max size\n\t\tif (this.cache.size >= this.maxSize) {\n\t\t\tconst firstKey = this.cache.keys().next().value;\n\t\t\tif (firstKey !== undefined) {\n\t\t\t\tthis.cache.delete(firstKey);\n\t\t\t}\n\t\t}\n\n\t\t// Add new entry\n\t\tconst ttl = customTtl ?? this.ttl;\n\t\tconst entry: CacheEntry<T> = {\n\t\t\tvalue,\n\t\t\texpiresAt: Date.now() + ttl\n\t\t};\n\n\t\tthis.cache.set(key, entry);\n\t}\n\n\t/**\n\t * Check if a key exists and is not expired\n\t */\n\thas(key: string): boolean {\n\t\tconst entry = this.cache.get(key);\n\t\tif (!entry) return false;\n\n\t\tif (Date.now() > entry.expiresAt) {\n\t\t\tthis.cache.delete(key);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Delete a specific key from the cache\n\t */\n\tdelete(key: string): boolean {\n\t\treturn this.cache.delete(key);\n\t}\n\n\t/**\n\t * Clear all entries from the cache\n\t */\n\tclear(): void {\n\t\tthis.cache.clear();\n\t\tthis.hits = 0;\n\t\tthis.misses = 0;\n\t}\n\n\t/**\n\t * Remove all expired entries\n\t */\n\tprune(): number {\n\t\tconst now = Date.now();\n\t\tlet pruned = 0;\n\n\t\tfor (const [key, entry] of this.cache.entries()) {\n\t\t\tif (now > entry.expiresAt) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t\tpruned++;\n\t\t\t}\n\t\t}\n\n\t\treturn pruned;\n\t}\n\n\t/**\n\t * Get cache statistics\n\t */\n\tgetStats(): CacheStats {\n\t\treturn {\n\t\t\thits: this.hits,\n\t\t\tmisses: this.misses,\n\t\t\tsize: this.cache.size,\n\t\t\tmaxSize: this.maxSize\n\t\t};\n\t}\n\n\t/**\n\t * Get hit rate percentage\n\t */\n\tgetHitRate(): number {\n\t\tconst total = this.hits + this.misses;\n\t\treturn total === 0 ? 0 : (this.hits / total) * 100;\n\t}\n\n\t/**\n\t * Get all keys in the cache (for debugging)\n\t */\n\tkeys(): string[] {\n\t\treturn Array.from(this.cache.keys());\n\t}\n\n\t/**\n\t * Get cache size\n\t */\n\tsize(): number {\n\t\treturn this.cache.size;\n\t}\n}\n\n/**\n * Cache key generator utility\n * Generates consistent cache keys from request parameters\n */\nexport function generateCacheKey(\n\tendpoint: string,\n\tparams?: Record<string, any>,\n\tuserId?: string\n): string {\n\tconst parts = [endpoint];\n\n\tif (userId) {\n\t\tparts.push(`user:${userId}`);\n\t}\n\n\tif (params) {\n\t\tconst sortedParams = Object.keys(params)\n\t\t\t.sort()\n\t\t\t.map((key) => `${key}=${JSON.stringify(params[key])}`)\n\t\t\t.join('&');\n\t\tparts.push(sortedParams);\n\t}\n\n\treturn parts.join('|');\n}\n\n/**\n * Stale-While-Revalidate Cache Wrapper\n *\n * Returns cached data immediately (if available) while fetching fresh data in the background.\n * Updates cache with fresh data when available.\n *\n * Usage:\n * ```typescript\n * const data = await staleWhileRevalidate(\n *   'skills-list',\n *   () => fetchSkills(),\n *   cache\n * );\n * ```\n */\nexport async function staleWhileRevalidate<T>(\n\tkey: string,\n\tfetchFn: () => Promise<T>,\n\tcache: LRUCache<T>,\n\tonRevalidate?: (data: T) => void\n): Promise<T> {\n\t// Try to get cached value\n\tconst cached = cache.get(key);\n\n\tif (cached !== null) {\n\t\t// Return cached value immediately\n\t\t// Revalidate in background\n\t\tfetchFn()\n\t\t\t.then((fresh) => {\n\t\t\t\tcache.set(key, fresh);\n\t\t\t\tif (onRevalidate) {\n\t\t\t\t\tonRevalidate(fresh);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.warn(`Failed to revalidate cache for key: ${key}`, error);\n\t\t\t});\n\n\t\treturn cached;\n\t}\n\n\t// No cached value, fetch fresh data\n\tconst fresh = await fetchFn();\n\tcache.set(key, fresh);\n\treturn fresh;\n}\n\n/**\n * Cache invalidation utilities\n */\nexport class CacheInvalidator {\n\tprivate cache: LRUCache<any>;\n\n\tconstructor(cache: LRUCache<any>) {\n\t\tthis.cache = cache;\n\t}\n\n\t/**\n\t * Invalidate all keys matching a pattern (glob-style)\n\t * Example: invalidatePattern('skills/*') invalidates all skill-related cache entries\n\t */\n\tinvalidatePattern(pattern: string): number {\n\t\tconst regex = new RegExp('^' + pattern.replace('*', '.*') + '$');\n\t\tlet invalidated = 0;\n\n\t\tfor (const key of this.cache.keys()) {\n\t\t\tif (regex.test(key)) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t\tinvalidated++;\n\t\t\t}\n\t\t}\n\n\t\treturn invalidated;\n\t}\n\n\t/**\n\t * Invalidate all keys containing a substring\n\t */\n\tinvalidateContaining(substring: string): number {\n\t\tlet invalidated = 0;\n\n\t\tfor (const key of this.cache.keys()) {\n\t\t\tif (key.includes(substring)) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t\tinvalidated++;\n\t\t\t}\n\t\t}\n\n\t\treturn invalidated;\n\t}\n\n\t/**\n\t * Invalidate all cache entries\n\t */\n\tinvalidateAll(): void {\n\t\tthis.cache.clear();\n\t}\n}\n\n/**\n * Global cache instance for API responses\n * Can be imported and used across the application\n */\nexport const apiCache = new LRUCache<any>({\n\tmaxSize: 100,\n\tttl: 5 * 60 * 1000 // 5 minutes\n});\n\n/**\n * Cache for skills list (longer TTL)\n */\nexport const skillsCache = new LRUCache<any>({\n\tmaxSize: 50,\n\tttl: 10 * 60 * 1000 // 10 minutes\n});\n\n/**\n * Cache for user-specific data (shorter TTL)\n */\nexport const userCache = new LRUCache<any>({\n\tmaxSize: 50,\n\tttl: 2 * 60 * 1000 // 2 minutes\n});\n","import { tokenManager } from './auth';\nimport {\n\tclassifyError,\n\tcreateAuthenticationError,\n\tcreateNetworkError,\n\tshouldRetry,\n\tgetRetryDelay,\n\ttype AppError\n} from '$lib/utils/errors';\nimport {\n\tskillsCache,\n\tuserCache,\n\tgenerateCacheKey,\n\tstaleWhileRevalidate\n} from '$lib/utils/cache';\nimport type {\n\tAuthResponse,\n\tListSkillsResponse,\n\tSkillInvocationRequest,\n\tSkillInvocationResponse\n} from './types';\n\nexport class ForgeAgentsClient {\n\tprivate baseUrl: string;\n\tprivate refreshPromise: Promise<void> | null = null;\n\tprivate maxRetries: number = 3;\n\tprivate timeout: number = 30000; // 30 seconds\n\n\tconstructor(baseUrl: string = 'http://localhost:8787') {\n\t\tthis.baseUrl = baseUrl;\n\t}\n\n\t/**\n\t * Retry wrapper for fetch operations\n\t */\n\tprivate async retryFetch<T>(\n\t\toperation: () => Promise<T>,\n\t\tcontext: string\n\t): Promise<T> {\n\t\tlet lastError: AppError | null = null;\n\n\t\tfor (let attempt = 0; attempt < this.maxRetries; attempt++) {\n\t\t\ttry {\n\t\t\t\treturn await operation();\n\t\t\t} catch (error) {\n\t\t\t\tconst appError = classifyError(error);\n\t\t\t\tlastError = appError;\n\n\t\t\t\t// Check if we should retry\n\t\t\t\tif (!shouldRetry(appError, attempt, this.maxRetries)) {\n\t\t\t\t\tthrow appError;\n\t\t\t\t}\n\n\t\t\t\t// Wait before retrying\n\t\t\t\tconst delay = getRetryDelay(appError, attempt);\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, delay));\n\t\t\t}\n\t\t}\n\n\t\t// All retries exhausted\n\t\tthrow lastError || createNetworkError(`${context} failed after ${this.maxRetries} attempts`);\n\t}\n\n\t/**\n\t * Fetch with timeout support\n\t */\n\tprivate async fetchWithTimeout(\n\t\turl: string,\n\t\toptions: RequestInit = {}\n\t): Promise<Response> {\n\t\tconst controller = new AbortController();\n\t\tconst timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n\t\t// Log request\n\t\tconsole.log('[ForgeAgents API] Request:', {\n\t\t\tmethod: options.method || 'GET',\n\t\t\turl,\n\t\t\theaders: options.headers,\n\t\t\thasBody: !!options.body\n\t\t});\n\n\t\ttry {\n\t\t\tconst startTime = Date.now();\n\t\t\tconst response = await fetch(url, {\n\t\t\t\t...options,\n\t\t\t\tsignal: controller.signal\n\t\t\t});\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// Log response\n\t\t\tconsole.log('[ForgeAgents API] Response:', {\n\t\t\t\tmethod: options.method || 'GET',\n\t\t\t\turl,\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t\tduration: `${duration}ms`,\n\t\t\t\tok: response.ok\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error: any) {\n\t\t\tconsole.error('[ForgeAgents API] Error:', {\n\t\t\t\tmethod: options.method || 'GET',\n\t\t\t\turl,\n\t\t\t\terror: error.message || error\n\t\t\t});\n\n\t\t\tif (error.name === 'AbortError') {\n\t\t\t\tthrow createNetworkError('Request timeout', `Request to ${url} timed out after ${this.timeout}ms`);\n\t\t\t}\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t}\n\n\tasync login(email: string, password: string): Promise<AuthResponse> {\n\t\treturn this.retryFetch(async () => {\n\t\t\ttry {\n\t\t\t\tconst response = await this.fetchWithTimeout(`${this.baseUrl}/api/v1/auth/login`, {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\tbody: JSON.stringify({ email, password })\n\t\t\t\t});\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tconst appError = classifyError(response);\n\t\t\t\t\tawait tokenManager.clearTokens();\n\t\t\t\t\tthrow appError;\n\t\t\t\t}\n\n\t\t\t\tconst data = await response.json();\n\t\t\t\tawait tokenManager.setTokens(data.access_token, data.refresh_token, data.expires_at);\n\t\t\t\treturn data;\n\t\t\t} catch (err) {\n\t\t\t\tawait tokenManager.clearTokens();\n\t\t\t\tthrow classifyError(err);\n\t\t\t}\n\t\t}, 'Login');\n\t}\n\n\tasync logout(): Promise<void> {\n\t\ttry {\n\t\t\tconst token = tokenManager.getAccessToken();\n\t\t\tif (token) {\n\t\t\t\tawait fetch(`${this.baseUrl}/api/v1/auth/logout`, {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: this.getAuthHeaders()\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.warn('Logout failed:', err);\n\t\t} finally {\n\t\t\tawait tokenManager.clearTokens();\n\t\t}\n\t}\n\n\tasync refreshAccessToken(): Promise<void> {\n\t\tif (this.refreshPromise) return this.refreshPromise;\n\t\tthis.refreshPromise = this._performRefresh();\n\t\ttry {\n\t\t\tawait this.refreshPromise;\n\t\t} finally {\n\t\t\tthis.refreshPromise = null;\n\t\t}\n\t}\n\n\tprivate async _performRefresh(): Promise<void> {\n\t\tconst refreshToken = tokenManager.getRefreshToken();\n\t\tif (!refreshToken) throw new Error('No refresh token available');\n\t\ttry {\n\t\t\tconst response = await fetch(`${this.baseUrl}/api/v1/auth/refresh`, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\tbody: JSON.stringify({ refresh_token: refreshToken })\n\t\t\t});\n\t\t\tif (!response.ok) {\n\t\t\t\tawait tokenManager.clearTokens();\n\t\t\t\tthrow new Error('Token refresh failed');\n\t\t\t}\n\t\t\tconst data = await response.json();\n\t\t\tawait tokenManager.setTokens(data.access_token, data.refresh_token, data.expires_at);\n\t\t} catch (err) {\n\t\t\tawait tokenManager.clearTokens();\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync listSkills(options?: { skipCache?: boolean }): Promise<ListSkillsResponse> {\n\t\tconst cacheKey = generateCacheKey('/api/v1/bds/skills');\n\n\t\t// Skip cache if requested\n\t\tif (options?.skipCache) {\n\t\t\tconst response = await this.authenticatedFetch<ListSkillsResponse>('/api/v1/bds/skills');\n\t\t\tskillsCache.set(cacheKey, response);\n\t\t\treturn response;\n\t\t}\n\n\t\t// Use stale-while-revalidate strategy\n\t\treturn staleWhileRevalidate(\n\t\t\tcacheKey,\n\t\t\t() => this.authenticatedFetch<ListSkillsResponse>('/api/v1/bds/skills'),\n\t\t\tskillsCache\n\t\t);\n\t}\n\n\tasync getSkill(skillId: string, options?: { skipCache?: boolean }): Promise<any> {\n\t\tconst cacheKey = generateCacheKey(`/api/v1/bds/skills/${skillId}`);\n\n\t\t// Skip cache if requested\n\t\tif (options?.skipCache) {\n\t\t\tconst response = await this.authenticatedFetch<any>(`/api/v1/bds/skills/${skillId}`);\n\t\t\tskillsCache.set(cacheKey, response);\n\t\t\treturn response;\n\t\t}\n\n\t\t// Use stale-while-revalidate strategy\n\t\treturn staleWhileRevalidate(\n\t\t\tcacheKey,\n\t\t\t() => this.authenticatedFetch<any>(`/api/v1/bds/skills/${skillId}`),\n\t\t\tskillsCache\n\t\t);\n\t}\n\n\tasync searchSkills(query: string, options?: { skipCache?: boolean }): Promise<ListSkillsResponse> {\n\t\tconst cacheKey = generateCacheKey('/api/v1/bds/skills/search', { query });\n\n\t\t// Skip cache if requested\n\t\tif (options?.skipCache) {\n\t\t\tconst response = await this.authenticatedFetch<ListSkillsResponse>(\n\t\t\t\t`/api/v1/bds/skills/search?query=${encodeURIComponent(query)}`\n\t\t\t);\n\t\t\tuserCache.set(cacheKey, response);\n\t\t\treturn response;\n\t\t}\n\n\t\t// Use stale-while-revalidate strategy (shorter TTL for search)\n\t\treturn staleWhileRevalidate(\n\t\t\tcacheKey,\n\t\t\t() =>\n\t\t\t\tthis.authenticatedFetch<ListSkillsResponse>(\n\t\t\t\t\t`/api/v1/bds/skills/search?query=${encodeURIComponent(query)}`\n\t\t\t\t),\n\t\t\tuserCache\n\t\t);\n\t}\n\n\tasync invokeSkill(\n\t\tskillId: string,\n\t\trequest: SkillInvocationRequest\n\t): Promise<SkillInvocationResponse> {\n\t\treturn this.authenticatedFetch<SkillInvocationResponse>(\n\t\t\t`/api/v1/bds/skills/${skillId}/invoke`,\n\t\t\t{\n\t\t\t\tmethod: 'POST',\n\t\t\t\tbody: JSON.stringify(request)\n\t\t\t}\n\t\t);\n\t}\n\n\tasync *invokeSkillStreaming(\n\t\tskillId: string,\n\t\trequest: SkillInvocationRequest\n\t): AsyncGenerator<{type: 'token' | 'metadata' | 'error', data: any}> {\n\t\tlet reader: ReadableStreamDefaultReader<Uint8Array> | null = null;\n\n\t\ttry {\n\t\t\tconst response = await this.fetchWithTimeout(\n\t\t\t\t`${this.baseUrl}/api/v1/bds/skills/${skillId}/invoke?stream=true`,\n\t\t\t\t{\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: this.getAuthHeaders(),\n\t\t\t\t\tbody: JSON.stringify(request)\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow classifyError(response);\n\t\t\t}\n\n\t\t\tif (!response.body) {\n\t\t\t\tthrow createNetworkError('No response body', 'Streaming response has no body');\n\t\t\t}\n\n\t\t\treader = response.body.getReader();\n\t\t\tconst decoder = new TextDecoder();\n\t\t\tlet buffer = '';\n\n\t\t\twhile (true) {\n\t\t\t\tconst { done, value } = await reader.read();\n\n\t\t\t\tif (done) {\n\t\t\t\t\t// Process any remaining data in buffer\n\t\t\t\t\tif (buffer.trim()) {\n\t\t\t\t\t\tconst lines = buffer.split('\\n');\n\t\t\t\t\t\tfor (const line of lines) {\n\t\t\t\t\t\t\tconst trimmed = line.trim();\n\t\t\t\t\t\t\tif (trimmed.startsWith('data: ')) {\n\t\t\t\t\t\t\t\tconst jsonStr = trimmed.substring(6);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst parsed = JSON.parse(jsonStr);\n\t\t\t\t\t\t\t\t\tif (parsed.token) {\n\t\t\t\t\t\t\t\t\t\tyield { type: 'token', data: parsed };\n\t\t\t\t\t\t\t\t\t} else if (parsed.metadata) {\n\t\t\t\t\t\t\t\t\t\tyield { type: 'metadata', data: parsed.metadata };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\tconsole.warn('Failed to parse SSE data:', jsonStr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Add to buffer\n\t\t\t\tbuffer += decoder.decode(value, { stream: true });\n\n\t\t\t\t// Process complete lines\n\t\t\t\tconst lines = buffer.split('\\n');\n\t\t\t\tbuffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n\t\t\t\tfor (const line of lines) {\n\t\t\t\t\tconst trimmed = line.trim();\n\t\t\t\t\tif (trimmed.startsWith('data: ')) {\n\t\t\t\t\t\tconst jsonStr = trimmed.substring(6); // Remove \"data: \" prefix\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst parsed = JSON.parse(jsonStr);\n\n\t\t\t\t\t\t\t// Check what type of message this is\n\t\t\t\t\t\t\tif (parsed.token !== undefined) {\n\t\t\t\t\t\t\t\t// Token message\n\t\t\t\t\t\t\t\tyield { type: 'token', data: parsed };\n\t\t\t\t\t\t\t} else if (parsed.metadata) {\n\t\t\t\t\t\t\t\t// Metadata message (final)\n\t\t\t\t\t\t\t\tyield { type: 'metadata', data: parsed.metadata };\n\t\t\t\t\t\t\t} else if (parsed.error) {\n\t\t\t\t\t\t\t\t// Error message\n\t\t\t\t\t\t\t\tyield { type: 'error', data: parsed.error };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.warn('Failed to parse SSE data:', jsonStr, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow classifyError(error);\n\t\t} finally {\n\t\t\tif (reader) {\n\t\t\t\ttry {\n\t\t\t\t\treader.releaseLock();\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Reader already released\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async getAuthToken(): Promise<string> {\n\t\tlet token = tokenManager.getAccessToken();\n\t\tif (!token) {\n\t\t\tif (tokenManager.isExpiringSoon()) {\n\t\t\t\tawait this.refreshAccessToken();\n\t\t\t\ttoken = tokenManager.getAccessToken();\n\t\t\t}\n\t\t\tif (!token) throw new Error('Not authenticated');\n\t\t}\n\t\treturn token;\n\t}\n\n\tprivate getAuthHeaders(): Record<string, string> {\n\t\tconst token = tokenManager.getAccessToken();\n\t\treturn {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token ? { Authorization: `Bearer ${token}` } : {})\n\t\t};\n\t}\n\n\tprivate async authenticatedFetch<T>(path: string, options: RequestInit = {}): Promise<T> {\n\t\treturn this.retryFetch(async () => {\n\t\t\ttry {\n\t\t\t\tconst token = await this.getAuthToken();\n\t\t\t\tconst response = await this.fetchWithTimeout(`${this.baseUrl}${path}`, {\n\t\t\t\t\t...options,\n\t\t\t\t\theaders: { ...this.getAuthHeaders(), ...(options.headers || {}) }\n\t\t\t\t});\n\n\t\t\t\t// Handle 401 - Try to refresh token once\n\t\t\t\tif (response.status === 401) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.refreshAccessToken();\n\t\t\t\t\t\t// Retry with new token (no retry wrapper to avoid double retry)\n\t\t\t\t\t\tconst retryResponse = await this.fetchWithTimeout(`${this.baseUrl}${path}`, {\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\theaders: { ...this.getAuthHeaders(), ...(options.headers || {}) }\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!retryResponse.ok) {\n\t\t\t\t\t\t\tthrow classifyError(retryResponse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn retryResponse.json();\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tthrow createAuthenticationError('Authentication failed after token refresh');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tthrow classifyError(response);\n\t\t\t\t}\n\n\t\t\t\treturn response.json();\n\t\t\t} catch (error) {\n\t\t\t\tthrow classifyError(error);\n\t\t\t}\n\t\t}, `API request to ${path}`);\n\t}\n}\n\nexport const forgeAgentsClient = new ForgeAgentsClient();\n"],"file":"_app/immutable/chunks/Bq26jQPn.js"}