var p=Object.defineProperty;var T=(c,e,t)=>e in c?p(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var u=(c,e,t)=>T(c,typeof e!="symbol"?e+"":e,t);import{c as h,s as b,g as A,a as w,t as i,b as S}from"./CIhCbREJ.js";class ${constructor(e="http://localhost:8787"){u(this,"baseUrl");u(this,"refreshPromise",null);u(this,"maxRetries",3);u(this,"timeout",3e4);this.baseUrl=e}async retryFetch(e,t){let s=null;for(let r=0;r<this.maxRetries;r++)try{return await e()}catch(a){const o=h(a);if(s=o,!b(o,r,this.maxRetries))throw o;const l=A(o,r);await new Promise(m=>setTimeout(m,l))}throw s||w(`${t} failed after ${this.maxRetries} attempts`)}async fetchWithTimeout(e,t={}){const s=new AbortController,r=setTimeout(()=>s.abort(),this.timeout);console.log("[ForgeAgents API] Request:",{method:t.method||"GET",url:e,headers:t.headers,hasBody:!!t.body});try{const a=Date.now(),o=await fetch(e,{...t,signal:s.signal}),l=Date.now()-a;return console.log("[ForgeAgents API] Response:",{method:t.method||"GET",url:e,status:o.status,statusText:o.statusText,duration:`${l}ms`,ok:o.ok}),o}catch(a){throw console.error("[ForgeAgents API] Error:",{method:t.method||"GET",url:e,error:a.message||a}),a.name==="AbortError"?w("Request timeout",`Request to ${e} timed out after ${this.timeout}ms`):a}finally{clearTimeout(r)}}async login(e,t){return this.retryFetch(async()=>{try{const s=await this.fetchWithTimeout(`${this.baseUrl}/api/v1/auth/login`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:e,password:t})});if(!s.ok){const a=h(s);throw await i.clearTokens(),a}const r=await s.json();return await i.setTokens(r.access_token,r.refresh_token,r.expires_at),r}catch(s){throw await i.clearTokens(),h(s)}},"Login")}async logout(){try{i.getAccessToken()&&await fetch(`${this.baseUrl}/api/v1/auth/logout`,{method:"POST",headers:this.getAuthHeaders()})}catch(e){console.warn("Logout failed:",e)}finally{await i.clearTokens()}}async refreshAccessToken(){if(this.refreshPromise)return this.refreshPromise;this.refreshPromise=this._performRefresh();try{await this.refreshPromise}finally{this.refreshPromise=null}}async _performRefresh(){const e=i.getRefreshToken();if(!e)throw new Error("No refresh token available");try{const t=await fetch(`${this.baseUrl}/api/v1/auth/refresh`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refresh_token:e})});if(!t.ok)throw await i.clearTokens(),new Error("Token refresh failed");const s=await t.json();await i.setTokens(s.access_token,s.refresh_token,s.expires_at)}catch(t){throw await i.clearTokens(),t}}async listSkills(){return this.authenticatedFetch("/api/v1/bds/skills")}async getSkill(e){return this.authenticatedFetch(`/api/v1/bds/skills/${e}`)}async searchSkills(e){return this.authenticatedFetch(`/api/v1/bds/skills/search?query=${encodeURIComponent(e)}`)}async invokeSkill(e,t){return this.authenticatedFetch(`/api/v1/bds/skills/${e}/invoke`,{method:"POST",body:JSON.stringify(t)})}async*invokeSkillStreaming(e,t){let s=null;try{const r=await this.fetchWithTimeout(`${this.baseUrl}/api/v1/bds/skills/${e}/invoke?stream=true`,{method:"POST",headers:this.getAuthHeaders(),body:JSON.stringify(t)});if(!r.ok)throw h(r);if(!r.body)throw w("No response body","Streaming response has no body");s=r.body.getReader();const a=new TextDecoder;let o="";for(;;){const{done:l,value:m}=await s.read();if(l){if(o.trim()){const k=o.split(`
`);for(const y of k){const d=y.trim();if(d.startsWith("data: ")){const n=d.substring(6);try{const f=JSON.parse(n);f.token?yield{type:"token",data:f}:f.metadata&&(yield{type:"metadata",data:f.metadata})}catch{console.warn("Failed to parse SSE data:",n)}}}}break}o+=a.decode(m,{stream:!0});const g=o.split(`
`);o=g.pop()||"";for(const k of g){const y=k.trim();if(y.startsWith("data: ")){const d=y.substring(6);try{const n=JSON.parse(d);n.token!==void 0?yield{type:"token",data:n}:n.metadata?yield{type:"metadata",data:n.metadata}:n.error&&(yield{type:"error",data:n.error})}catch(n){console.warn("Failed to parse SSE data:",d,n)}}}}}catch(r){throw h(r)}finally{if(s)try{s.releaseLock()}catch{}}}async getAuthToken(){let e=i.getAccessToken();if(!e&&(i.isExpiringSoon()&&(await this.refreshAccessToken(),e=i.getAccessToken()),!e))throw new Error("Not authenticated");return e}getAuthHeaders(){const e=i.getAccessToken();return{"Content-Type":"application/json",...e?{Authorization:`Bearer ${e}`}:{}}}async authenticatedFetch(e,t={}){return this.retryFetch(async()=>{try{const s=await this.getAuthToken(),r=await this.fetchWithTimeout(`${this.baseUrl}${e}`,{...t,headers:{...this.getAuthHeaders(),...t.headers||{}}});if(r.status===401)try{await this.refreshAccessToken();const a=await this.fetchWithTimeout(`${this.baseUrl}${e}`,{...t,headers:{...this.getAuthHeaders(),...t.headers||{}}});if(!a.ok)throw h(a);return a.json()}catch{throw S("Authentication failed after token refresh")}if(!r.ok)throw h(r);return r.json()}catch(s){throw h(s)}},`API request to ${e}`)}}const R=new $;export{R as f};
