{"version":3,"file":"0OOX5gzM.js","sources":["../../../../../../src/lib/utils/accessibility.ts"],"sourcesContent":["/**\n * Accessibility Utilities\n *\n * Provides helpers for ARIA compliance, keyboard navigation,\n * focus management, and screen reader support.\n */\n\n/**\n * Focus trap utility for modals and dialogs\n * Keeps focus within a container when Tab/Shift+Tab is pressed\n */\nexport class FocusTrap {\n  private container: HTMLElement;\n  private previousFocus: HTMLElement | null = null;\n  private focusableElements: HTMLElement[] = [];\n\n  constructor(container: HTMLElement) {\n    this.container = container;\n  }\n\n  /**\n   * Activate the focus trap\n   */\n  activate() {\n    // Store currently focused element\n    this.previousFocus = document.activeElement as HTMLElement;\n\n    // Get all focusable elements\n    this.updateFocusableElements();\n\n    // Focus first element\n    if (this.focusableElements.length > 0) {\n      setTimeout(() => {\n        this.focusableElements[0]?.focus();\n      }, 10);\n    }\n\n    // Add event listeners\n    this.container.addEventListener('keydown', this.handleKeyDown);\n  }\n\n  /**\n   * Deactivate the focus trap and restore previous focus\n   */\n  deactivate() {\n    this.container.removeEventListener('keydown', this.handleKeyDown);\n\n    // Restore focus to previously focused element\n    if (this.previousFocus && typeof this.previousFocus.focus === 'function') {\n      setTimeout(() => {\n        this.previousFocus?.focus();\n      }, 10);\n    }\n  }\n\n  /**\n   * Update list of focusable elements\n   */\n  private updateFocusableElements() {\n    const focusableSelectors = [\n      'a[href]',\n      'button:not([disabled])',\n      'textarea:not([disabled])',\n      'input:not([disabled])',\n      'select:not([disabled])',\n      '[tabindex]:not([tabindex=\"-1\"])'\n    ].join(',');\n\n    this.focusableElements = Array.from(\n      this.container.querySelectorAll<HTMLElement>(focusableSelectors)\n    ).filter(el => {\n      // Filter out hidden elements\n      return el.offsetParent !== null;\n    });\n  }\n\n  /**\n   * Handle Tab/Shift+Tab to trap focus\n   */\n  private handleKeyDown = (e: KeyboardEvent) => {\n    if (e.key !== 'Tab') return;\n\n    this.updateFocusableElements();\n\n    const firstElement = this.focusableElements[0];\n    const lastElement = this.focusableElements[this.focusableElements.length - 1];\n    const activeElement = document.activeElement as HTMLElement;\n\n    if (e.shiftKey) {\n      // Shift+Tab: moving backwards\n      if (activeElement === firstElement) {\n        e.preventDefault();\n        lastElement?.focus();\n      }\n    } else {\n      // Tab: moving forwards\n      if (activeElement === lastElement) {\n        e.preventDefault();\n        firstElement?.focus();\n      }\n    }\n  };\n}\n\n/**\n * Announce message to screen readers using ARIA live region\n */\nexport function announceToScreenReader(message: string, priority: 'polite' | 'assertive' = 'polite') {\n  // Create or get live region\n  let liveRegion = document.getElementById('aria-live-region');\n\n  if (!liveRegion) {\n    liveRegion = document.createElement('div');\n    liveRegion.id = 'aria-live-region';\n    liveRegion.setAttribute('role', 'status');\n    liveRegion.setAttribute('aria-live', priority);\n    liveRegion.setAttribute('aria-atomic', 'true');\n    liveRegion.className = 'sr-only';\n    liveRegion.style.position = 'absolute';\n    liveRegion.style.left = '-10000px';\n    liveRegion.style.width = '1px';\n    liveRegion.style.height = '1px';\n    liveRegion.style.overflow = 'hidden';\n    document.body.appendChild(liveRegion);\n  }\n\n  // Update priority if changed\n  liveRegion.setAttribute('aria-live', priority);\n\n  // Clear then set message (forces screen reader announcement)\n  liveRegion.textContent = '';\n  setTimeout(() => {\n    liveRegion!.textContent = message;\n  }, 100);\n}\n\n/**\n * Generate unique ID for ARIA relationships\n */\nlet idCounter = 0;\nexport function generateAriaId(prefix: string = 'aria'): string {\n  idCounter++;\n  return `${prefix}-${idCounter}-${Date.now()}`;\n}\n\n/**\n * Get all focusable elements within a container\n */\nexport function getFocusableElements(container: HTMLElement): HTMLElement[] {\n  const focusableSelectors = [\n    'a[href]',\n    'button:not([disabled])',\n    'textarea:not([disabled])',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    '[tabindex]:not([tabindex=\"-1\"])'\n  ].join(',');\n\n  return Array.from(\n    container.querySelectorAll<HTMLElement>(focusableSelectors)\n  ).filter(el => el.offsetParent !== null);\n}\n\n/**\n * Check if element is visible (for screen readers)\n */\nexport function isVisible(element: HTMLElement): boolean {\n  return !!(\n    element.offsetWidth ||\n    element.offsetHeight ||\n    element.getClientRects().length\n  );\n}\n\n/**\n * Set up keyboard navigation for list/grid\n */\nexport interface KeyboardNavigationOptions {\n  container: HTMLElement;\n  items: HTMLElement[];\n  currentIndex: number;\n  onIndexChange: (newIndex: number) => void;\n  onSelect?: (index: number) => void;\n  orientation?: 'vertical' | 'horizontal' | 'grid';\n  loop?: boolean; // Whether to loop from end to start\n}\n\nexport function setupKeyboardNavigation(options: KeyboardNavigationOptions) {\n  const {\n    container,\n    items,\n    currentIndex,\n    onIndexChange,\n    onSelect,\n    orientation = 'vertical',\n    loop = true\n  } = options;\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    let newIndex = currentIndex;\n    let handled = false;\n\n    switch (e.key) {\n      case 'ArrowDown':\n        if (orientation === 'vertical' || orientation === 'grid') {\n          newIndex = currentIndex + 1;\n          handled = true;\n        }\n        break;\n\n      case 'ArrowUp':\n        if (orientation === 'vertical' || orientation === 'grid') {\n          newIndex = currentIndex - 1;\n          handled = true;\n        }\n        break;\n\n      case 'ArrowRight':\n        if (orientation === 'horizontal' || orientation === 'grid') {\n          newIndex = currentIndex + 1;\n          handled = true;\n        }\n        break;\n\n      case 'ArrowLeft':\n        if (orientation === 'horizontal' || orientation === 'grid') {\n          newIndex = currentIndex - 1;\n          handled = true;\n        }\n        break;\n\n      case 'Home':\n        newIndex = 0;\n        handled = true;\n        break;\n\n      case 'End':\n        newIndex = items.length - 1;\n        handled = true;\n        break;\n\n      case 'Enter':\n      case ' ':\n        if (onSelect) {\n          onSelect(currentIndex);\n          handled = true;\n        }\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n\n      // Clamp or loop index\n      if (newIndex < 0) {\n        newIndex = loop ? items.length - 1 : 0;\n      } else if (newIndex >= items.length) {\n        newIndex = loop ? 0 : items.length - 1;\n      }\n\n      if (newIndex !== currentIndex) {\n        onIndexChange(newIndex);\n      }\n    }\n  };\n\n  container.addEventListener('keydown', handleKeyDown);\n\n  // Return cleanup function\n  return () => {\n    container.removeEventListener('keydown', handleKeyDown);\n  };\n}\n\n/**\n * Screen reader only (sr-only) class styles\n * Use this in your CSS to hide elements visually but keep them for screen readers\n */\nexport const srOnlyStyles = `\n  .sr-only {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    padding: 0;\n    margin: -1px;\n    overflow: hidden;\n    clip: rect(0, 0, 0, 0);\n    white-space: nowrap;\n    border-width: 0;\n  }\n\n  .sr-only-focusable:focus,\n  .sr-only-focusable:active {\n    position: static;\n    width: auto;\n    height: auto;\n    overflow: visible;\n    clip: auto;\n    white-space: normal;\n  }\n`;\n\n/**\n * Skip link helper\n * Creates a skip navigation link for keyboard users\n */\nexport function createSkipLink(targetId: string, text: string = 'Skip to main content'): HTMLElement {\n  const skipLink = document.createElement('a');\n  skipLink.href = `#${targetId}`;\n  skipLink.className = 'skip-link sr-only-focusable';\n  skipLink.textContent = text;\n  skipLink.style.position = 'absolute';\n  skipLink.style.top = '0';\n  skipLink.style.left = '0';\n  skipLink.style.zIndex = '10000';\n  skipLink.style.padding = '1rem';\n  skipLink.style.backgroundColor = 'var(--color-brass, #B8860B)';\n  skipLink.style.color = 'var(--color-midnight, #0A0E1A)';\n  skipLink.style.textDecoration = 'none';\n  skipLink.style.fontWeight = 'bold';\n\n  skipLink.addEventListener('click', (e) => {\n    e.preventDefault();\n    const target = document.getElementById(targetId);\n    if (target) {\n      target.focus();\n      target.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n  });\n\n  return skipLink;\n}\n\n/**\n * WCAG 2.1 AA Contrast checker\n * Returns true if contrast ratio meets WCAG AA standards\n */\nexport function meetsContrastRequirements(\n  foreground: string,\n  background: string,\n  largeText: boolean = false\n): boolean {\n  const requiredRatio = largeText ? 3 : 4.5; // AA standards\n  const ratio = getContrastRatio(foreground, background);\n  return ratio >= requiredRatio;\n}\n\n/**\n * Calculate contrast ratio between two colors\n */\nfunction getContrastRatio(color1: string, color2: string): number {\n  const lum1 = getLuminance(color1);\n  const lum2 = getLuminance(color2);\n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n  return (brightest + 0.05) / (darkest + 0.05);\n}\n\n/**\n * Calculate relative luminance of a color\n */\nfunction getLuminance(color: string): number {\n  // This is a simplified version - would need full implementation for production\n  // For now, return a placeholder\n  return 0.5;\n}\n\n/**\n * Manage focus return after modal close\n */\nexport class FocusManager {\n  private stack: HTMLElement[] = [];\n\n  push(element: HTMLElement) {\n    this.stack.push(element);\n  }\n\n  pop(): HTMLElement | undefined {\n    return this.stack.pop();\n  }\n\n  restoreFocus() {\n    const element = this.pop();\n    if (element && typeof element.focus === 'function') {\n      setTimeout(() => {\n        element?.focus();\n      }, 10);\n    }\n  }\n}\n\nexport const globalFocusManager = new FocusManager();\n"],"names":["FocusTrap","constructor","container","__publicField","this","e","key","updateFocusableElements","firstElement","focusableElements","lastElement","length","activeElement","document","shiftKey","preventDefault","focus","activate","previousFocus","setTimeout","addEventListener","handleKeyDown","deactivate","removeEventListener","focusableSelectors","join","Array","from","querySelectorAll","filter","el","offsetParent","announceToScreenReader","message","priority","liveRegion","getElementById","createElement","id","setAttribute","className","style","position","left","width","height","overflow","body","appendChild","textContent","idCounter","generateAriaId","prefix","Date","now"],"mappings":"0JAWO,MAAMA,EAKX,WAAAC,CAAYC,GAJJC,EAAAC,KAAA,aACAD,EAAAC,KAAA,gBAAoC,MACpCD,EAAAC,KAAA,oBAAmC,IAiEnCD,EAAAC,KAAA,gBAAiBC,IACvB,GAAc,QAAVA,EAAEC,IAAe,OAErBF,KAAKG,0BAEL,MAAMC,EAAeJ,KAAKK,kBAAkB,GACtCC,EAAcN,KAAKK,kBAAkBL,KAAKK,kBAAkBE,OAAS,GACrEC,EAAgBC,SAASD,cAE3BP,EAAES,SAEAF,IAAkBJ,IACpBH,EAAEU,iBACFL,GAAaM,SAIXJ,IAAkBF,IACpBL,EAAEU,iBACFP,GAAcQ,WAjFlBZ,KAAKF,UAAYA,CACnB,CAKA,QAAAe,GAEEb,KAAKc,cAAgBL,SAASD,cAG9BR,KAAKG,0BAGDH,KAAKK,kBAAkBE,OAAS,GAClCQ,WAAW,KACTf,KAAKK,kBAAkB,IAAIO,SAC1B,IAILZ,KAAKF,UAAUkB,iBAAiB,UAAWhB,KAAKiB,cAClD,CAKA,UAAAC,GACElB,KAAKF,UAAUqB,oBAAoB,UAAWnB,KAAKiB,eAG/CjB,KAAKc,eAAqD,mBAA7Bd,KAAKc,cAAcF,OAClDG,WAAW,KACTf,KAAKc,eAAeF,SACnB,GAEP,CAKQ,uBAAAT,GACN,MAAMiB,EAAqB,CACzB,UACA,yBACA,2BACA,wBACA,yBACA,mCACAC,KAAK,KAEPrB,KAAKK,kBAAoBiB,MAAMC,KAC7BvB,KAAKF,UAAU0B,iBAA8BJ,IAC7CK,OAAOC,GAEoB,OAApBA,EAAGC,aAEd,EAiCK,SAASC,EAAuBC,EAAiBC,EAAmC,UAEzF,IAAIC,EAAatB,SAASuB,eAAe,oBAEpCD,IACHA,EAAatB,SAASwB,cAAc,OACpCF,EAAWG,GAAK,mBAChBH,EAAWI,aAAa,OAAQ,UAChCJ,EAAWI,aAAa,YAAaL,GACrCC,EAAWI,aAAa,cAAe,QACvCJ,EAAWK,UAAY,UACvBL,EAAWM,MAAMC,SAAW,WAC5BP,EAAWM,MAAME,KAAO,WACxBR,EAAWM,MAAMG,MAAQ,MACzBT,EAAWM,MAAMI,OAAS,MAC1BV,EAAWM,MAAMK,SAAW,SAC5BjC,SAASkC,KAAKC,YAAYb,IAI5BA,EAAWI,aAAa,YAAaL,GAGrCC,EAAWc,YAAc,GACzB9B,WAAW,KACTgB,EAAYc,YAAchB,GACzB,IACL,CAKA,IAAIiB,EAAY,EACT,SAASC,EAAeC,EAAiB,QAE9C,OADAF,IACO,GAAGE,KAAUF,KAAaG,KAAKC,OACxC"}