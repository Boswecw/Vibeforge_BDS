{"version":3,"file":"Cf9ICnXl.js","sources":["../../../../../../src/lib/types/agents.ts","../../../../../../src/lib/services/streaming.ts"],"sourcesContent":["/**\n * Agent Type Definitions for VibeForge BDS\n *\n * Defines types for all agent workflows following the PAORT cycle.\n */\n\n// ═══════════════════════════════════════════════════════════════════════\n// PAORT Stage Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport enum PAORTStage {\n\tPLAN = 'PLAN',\n\tACT = 'ACT',\n\tOBSERVE = 'OBSERVE',\n\tREFLECT = 'REFLECT',\n\tTRANSITION = 'TRANSITION'\n}\n\nexport interface StageInput {\n\tstage: PAORTStage;\n\tdata: Record<string, unknown>;\n\tpreviousStageOutput?: StageOutput;\n}\n\nexport interface StageOutput {\n\tstage: PAORTStage;\n\tdata: Record<string, unknown>;\n\tsummary: string;\n\tstatus: 'success' | 'failure' | 'partial';\n\tmetrics?: StageMetrics;\n}\n\nexport interface StageMetrics {\n\ttokensUsed: number;\n\tcost: number;\n\tlatencyMs: number;\n\tmodelUsed: string;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Session Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport enum SessionStatus {\n\tPENDING = 'PENDING',\n\tRUNNING = 'RUNNING',\n\tCOMPLETED = 'COMPLETED',\n\tFAILED = 'FAILED',\n\tCANCELLED = 'CANCELLED'\n}\n\nexport interface BaseSession {\n\tid: string;\n\ttype: 'planning' | 'execution' | 'evaluation' | 'coordination';\n\tstatus: SessionStatus;\n\tcreatedAt: Date;\n\tstartedAt?: Date;\n\tcompletedAt?: Date;\n\tcurrentStage?: PAORTStage;\n\terror?: string;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Planning Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface PlanningRequest {\n\ttitle: string;\n\tdescription: string;\n\tcontext?: Record<string, unknown>;\n\trequirements?: string[];\n\tconstraints?: string[];\n}\n\nexport interface PlanningSession extends BaseSession {\n\ttype: 'planning';\n\trequest: PlanningRequest;\n\tstages: PlanningStages;\n\tdeliverable?: PlanningDeliverable;\n}\n\nexport interface PlanningStages {\n\tplan?: StageOutput;\n\tact?: StageOutput;\n\tobserve?: StageOutput;\n\treflect?: StageOutput;\n}\n\nexport interface PlanningDeliverable {\n\tplan: {\n\t\ttitle: string;\n\t\toverview: string;\n\t\tsteps: PlanStep[];\n\t\testimatedEffort: string;\n\t\trisks: string[];\n\t};\n\tprompt: string;\n\tmetadata: {\n\t\ttotalTokens: number;\n\t\ttotalCost: number;\n\t\tduration: number;\n\t};\n}\n\nexport interface PlanStep {\n\tid: string;\n\ttitle: string;\n\tdescription: string;\n\tdependencies: string[];\n\testimatedEffort: string;\n\tacceptanceCriteria: string[];\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Execution Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface ExecutionRequest {\n\tplanSessionId: string;\n\tplan: PlanningDeliverable;\n\toptions?: ExecutionOptions;\n}\n\nexport interface ExecutionOptions {\n\trunTests: boolean;\n\tgenerateDocs: boolean;\n\tautoCommit: boolean;\n}\n\nexport interface ExecutionSession extends BaseSession {\n\ttype: 'execution';\n\trequest: ExecutionRequest;\n\tstages: ExecutionStages;\n\tresult?: ExecutionResult;\n}\n\nexport interface ExecutionStages {\n\tplan?: StageOutput;\n\tact?: StageOutput;\n\tobserve?: StageOutput;\n\treflect?: StageOutput;\n}\n\nexport interface ExecutionResult {\n\tcode: {\n\t\tfilesModified: FileModification[];\n\t\tfilesCreated: FileCreation[];\n\t\tfilesDeleted: string[];\n\t};\n\ttests: TestResults;\n\tmetrics: ExecutionMetrics;\n\trollbackPoint?: string;\n}\n\nexport interface FileModification {\n\tpath: string;\n\tadditions: number;\n\tdeletions: number;\n\tdiff: string;\n}\n\nexport interface FileCreation {\n\tpath: string;\n\tcontent: string;\n\tlines: number;\n}\n\nexport interface TestResults {\n\tpassed: number;\n\tfailed: number;\n\tskipped: number;\n\ttotal: number;\n\tcoverage?: {\n\t\tlines: number;\n\t\tfunctions: number;\n\t\tbranches: number;\n\t\tstatements: number;\n\t};\n\tfailures: TestFailure[];\n}\n\nexport interface TestFailure {\n\ttestName: string;\n\tfilePath: string;\n\terror: string;\n\tstack?: string;\n}\n\nexport interface ExecutionMetrics {\n\ttokensUsed: number;\n\tcost: number;\n\tduration: number;\n\tmodelUsed: string;\n\tlinesOfCode: number;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Evaluator Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface EvaluationRequest {\n\texecutionSessionId: string;\n\tresult: ExecutionResult;\n\tcriteria?: EvaluationCriteria;\n}\n\nexport interface EvaluationCriteria {\n\tcheckSASCompliance: boolean;\n\tcheckTestCoverage: boolean;\n\tcheckCodeQuality: boolean;\n\tcheckPerformance: boolean;\n}\n\nexport interface EvaluationSession extends BaseSession {\n\ttype: 'evaluation';\n\trequest: EvaluationRequest;\n\tstages: EvaluationStages;\n\tassessment?: EvaluationAssessment;\n}\n\nexport interface EvaluationStages {\n\tplan?: StageOutput;\n\tact?: StageOutput;\n\tobserve?: StageOutput;\n\treflect?: StageOutput;\n}\n\nexport interface EvaluationAssessment {\n\tqualityScore: number; // 0-100\n\tsasCompliance: SASCompliance;\n\tcodeReview: CodeReview;\n\timprovements: Improvement[];\n\tmetrics: EvaluationMetrics;\n}\n\nexport interface SASCompliance {\n\tcompliant: boolean;\n\tviolations: SASViolation[];\n\tpassedChecks: string[];\n\tfailedChecks: string[];\n}\n\nexport interface SASViolation {\n\trule: string;\n\tseverity: 'error' | 'warning' | 'info';\n\tfilePath: string;\n\tlineNumber?: number;\n\tdescription: string;\n\tsuggestion: string;\n}\n\nexport interface CodeReview {\n\tfindings: CodeFinding[];\n\tsummary: string;\n\toverallRating: number; // 0-10\n}\n\nexport interface CodeFinding {\n\tid: string;\n\ttype: 'bug' | 'smell' | 'security' | 'performance' | 'style';\n\tseverity: 'critical' | 'high' | 'medium' | 'low';\n\tfilePath: string;\n\tlineNumber?: number;\n\tdescription: string;\n\tsuggestion: string;\n\tcodeSnippet?: string;\n}\n\nexport interface Improvement {\n\tid: string;\n\tpriority: 'critical' | 'high' | 'medium' | 'low';\n\tcategory: string;\n\tdescription: string;\n\tbefore: string;\n\tafter: string;\n\timpact: string;\n\teffort: string;\n}\n\nexport interface EvaluationMetrics {\n\ttokensUsed: number;\n\tcost: number;\n\tduration: number;\n\tmodelUsed: string;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Coordinator Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface WorkflowRequest {\n\ttask: string;\n\tagents: AgentNode[];\n\tdependencies: Dependency[];\n\toptions?: Record<string, unknown>;\n}\n\nexport interface AgentNode {\n\tid: string;\n\ttype: 'planning' | 'execution' | 'evaluation';\n\tconfig: Record<string, unknown>;\n\tposition: { x: number; y: number };\n}\n\nexport interface Dependency {\n\tfrom: string; // Agent node ID\n\tto: string; // Agent node ID\n\tdataMapping?: Record<string, string>;\n}\n\nexport interface CoordinationSession extends BaseSession {\n\ttype: 'coordination';\n\trequest: WorkflowRequest;\n\tworkflow: WorkflowExecution;\n}\n\nexport interface WorkflowExecution {\n\tnodes: WorkflowNodeExecution[];\n\tstatus: WorkflowStatus;\n\tstartedAt?: Date;\n\tcompletedAt?: Date;\n\terror?: string;\n}\n\nexport interface WorkflowNodeExecution {\n\tnodeId: string;\n\tsessionId?: string;\n\tstatus: 'pending' | 'running' | 'completed' | 'failed';\n\tstartedAt?: Date;\n\tcompletedAt?: Date;\n\terror?: string;\n\tprogress?: number; // 0-100\n}\n\nexport enum WorkflowStatus {\n\tPENDING = 'PENDING',\n\tRUNNING = 'RUNNING',\n\tCOMPLETED = 'COMPLETED',\n\tFAILED = 'FAILED',\n\tPARTIAL = 'PARTIAL'\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Streaming Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface StreamChunk {\n\ttype: 'chunk' | 'stage_start' | 'stage_end' | 'complete' | 'error';\n\tdata: unknown;\n\ttimestamp: Date;\n}\n\nexport interface StageStreamChunk extends StreamChunk {\n\ttype: 'chunk';\n\tdata: {\n\t\tstage: PAORTStage;\n\t\tcontent: string;\n\t};\n}\n\nexport interface StageStartChunk extends StreamChunk {\n\ttype: 'stage_start';\n\tdata: {\n\t\tstage: PAORTStage;\n\t};\n}\n\nexport interface StageEndChunk extends StreamChunk {\n\ttype: 'stage_end';\n\tdata: {\n\t\tstage: PAORTStage;\n\t\toutput: StageOutput;\n\t};\n}\n\nexport interface CompleteChunk extends StreamChunk {\n\ttype: 'complete';\n\tdata: {\n\t\tsessionId: string;\n\t\tresult: unknown;\n\t};\n}\n\nexport interface ErrorChunk extends StreamChunk {\n\ttype: 'error';\n\tdata: {\n\t\terror: string;\n\t\tstage?: PAORTStage;\n\t};\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Union Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport type AgentSession = PlanningSession | ExecutionSession | EvaluationSession | CoordinationSession;\n\nexport type AgentRequest = PlanningRequest | ExecutionRequest | EvaluationRequest | WorkflowRequest;\n\nexport type AgentResult = PlanningDeliverable | ExecutionResult | EvaluationAssessment | WorkflowExecution;\n","/**\n * SSE Streaming Service\n *\n * Handles Server-Sent Events (SSE) streaming for real-time agent output.\n */\n\nimport type { StreamChunk } from '$lib/types/agents';\nimport { classifyError, createNetworkError, type AppError } from '$lib/utils/errors';\n\n// ═══════════════════════════════════════════════════════════════════════\n// Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface StreamOptions {\n\tonChunk?: (chunk: string) => void;\n\tonStageStart?: (stage: string) => void;\n\tonStageEnd?: (stage: string, output: unknown) => void;\n\tonComplete?: (result: unknown) => void;\n\tonError?: (error: AppError) => void;\n\treconnect?: boolean;\n\treconnectDelay?: number;\n\tmaxReconnectAttempts?: number;\n}\n\nexport interface StreamSubscription {\n\tclose: () => void;\n\tpause: () => void;\n\tresume: () => void;\n\treadonly isActive: boolean;\n\treadonly isPaused: boolean;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Streaming Service\n// ═══════════════════════════════════════════════════════════════════════\n\nclass StreamingService {\n\tprivate activeStreams: Map<string, EventSource> = new Map();\n\n\t/**\n\t * Subscribe to an SSE stream\n\t */\n\tsubscribe(\n\t\turl: string,\n\t\toptions: StreamOptions = {}\n\t): StreamSubscription {\n\t\tconst {\n\t\t\tonChunk,\n\t\t\tonStageStart,\n\t\t\tonStageEnd,\n\t\t\tonComplete,\n\t\t\tonError,\n\t\t\treconnect = true,\n\t\t\treconnectDelay = 3000,\n\t\t\tmaxReconnectAttempts = 5\n\t\t} = options;\n\n\t\tlet eventSource: EventSource | null = null;\n\t\tlet reconnectAttempts = 0;\n\t\tlet isPaused = false;\n\t\tlet isClosed = false;\n\t\tlet reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n\n\t\tconst connect = () => {\n\t\t\tif (isClosed) return;\n\n\t\t\ttry {\n\t\t\t\teventSource = new EventSource(url);\n\t\t\t\tthis.activeStreams.set(url, eventSource);\n\n\t\t\t\t// Handle chunk messages\n\t\t\t\teventSource.addEventListener('chunk', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'chunk' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst chunkData = chunk.data as { content?: string };\n\t\t\t\t\t\t\tif (chunkData.content && onChunk) {\n\t\t\t\t\t\t\t\tonChunk(chunkData.content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse chunk:', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle stage start\n\t\t\t\teventSource.addEventListener('stage_start', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'stage_start' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst stageData = chunk.data as { stage?: string };\n\t\t\t\t\t\t\tif (stageData.stage && onStageStart) {\n\t\t\t\t\t\t\t\tonStageStart(stageData.stage);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse stage_start:', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle stage end\n\t\t\t\teventSource.addEventListener('stage_end', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'stage_end' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst stageData = chunk.data as { stage?: string; output?: unknown };\n\t\t\t\t\t\t\tif (stageData.stage && onStageEnd) {\n\t\t\t\t\t\t\t\tonStageEnd(stageData.stage, stageData.output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse stage_end:', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle completion\n\t\t\t\teventSource.addEventListener('complete', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'complete' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst completeData = chunk.data as { result?: unknown };\n\t\t\t\t\t\t\tif (onComplete) {\n\t\t\t\t\t\t\t\tonComplete(completeData.result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse complete:', err);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcloseStream();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle errors from stream\n\t\t\t\teventSource.addEventListener('error', () => {\n\t\t\t\t\tif (isClosed) return;\n\n\t\t\t\t\tconst error = createNetworkError('Stream connection error');\n\n\t\t\t\t\t// Attempt reconnection\n\t\t\t\t\tif (reconnect && reconnectAttempts < maxReconnectAttempts) {\n\t\t\t\t\t\treconnectAttempts++;\n\t\t\t\t\t\tconsole.log(`[StreamingService] Reconnecting (attempt ${reconnectAttempts}/${maxReconnectAttempts})...`);\n\n\t\t\t\t\t\teventSource?.close();\n\t\t\t\t\t\tthis.activeStreams.delete(url);\n\n\t\t\t\t\t\treconnectTimer = setTimeout(() => {\n\t\t\t\t\t\t\tconnect();\n\t\t\t\t\t\t}, reconnectDelay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (onError) {\n\t\t\t\t\t\t\tonError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcloseStream();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reset reconnect attempts on successful connection\n\t\t\t\teventSource.addEventListener('open', () => {\n\t\t\t\t\treconnectAttempts = 0;\n\t\t\t\t\tconsole.log('[StreamingService] Stream connected');\n\t\t\t\t});\n\n\t\t\t} catch (err) {\n\t\t\t\tconst error = classifyError(err);\n\t\t\t\tif (onError) {\n\t\t\t\t\tonError(error);\n\t\t\t\t}\n\t\t\t\tcloseStream();\n\t\t\t}\n\t\t};\n\n\t\tconst closeStream = () => {\n\t\t\tisClosed = true;\n\t\t\tisPaused = false;\n\n\t\t\tif (reconnectTimer) {\n\t\t\t\tclearTimeout(reconnectTimer);\n\t\t\t\treconnectTimer = null;\n\t\t\t}\n\n\t\t\tif (eventSource) {\n\t\t\t\teventSource.close();\n\t\t\t\tthis.activeStreams.delete(url);\n\t\t\t\teventSource = null;\n\t\t\t}\n\t\t};\n\n\t\tconst pauseStream = () => {\n\t\t\tisPaused = true;\n\t\t};\n\n\t\tconst resumeStream = () => {\n\t\t\tisPaused = false;\n\t\t};\n\n\t\t// Start the connection\n\t\tconnect();\n\n\t\t// Return subscription interface\n\t\treturn {\n\t\t\tclose: closeStream,\n\t\t\tpause: pauseStream,\n\t\t\tresume: resumeStream,\n\t\t\tget isActive() {\n\t\t\t\treturn !isClosed && eventSource !== null;\n\t\t\t},\n\t\t\tget isPaused() {\n\t\t\t\treturn isPaused;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Close all active streams\n\t */\n\tcloseAll(): void {\n\t\tthis.activeStreams.forEach((eventSource) => {\n\t\t\teventSource.close();\n\t\t});\n\t\tthis.activeStreams.clear();\n\t}\n\n\t/**\n\t * Get count of active streams\n\t */\n\tget activeStreamCount(): number {\n\t\treturn this.activeStreams.size;\n\t}\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Export Singleton\n// ═══════════════════════════════════════════════════════════════════════\n\nexport const streamingService = new StreamingService();\n"],"names":["PAORTStage","SessionStatus","WorkflowStatus","streamingService","constructor","__publicField","this","Map","subscribe","url","options","onChunk","onStageStart","onStageEnd","onComplete","onError","reconnect","reconnectDelay","maxReconnectAttempts","eventSource","reconnectAttempts","isPaused","isClosed","reconnectTimer","connect","EventSource","activeStreams","set","addEventListener","event","chunk","JSON","parse","data","type","chunkData","content","err","stageData","stage","output","completeData","result","closeStream","error","createNetworkError","close","delete","setTimeout","classifyError","clearTimeout","pause","resume","isActive","closeAll","forEach","clear","activeStreamCount","size"],"mappings":"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"}