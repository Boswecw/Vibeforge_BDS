{"version":3,"file":"streaming.js","sources":["../../../../src/lib/types/agents.ts","../../../../src/lib/services/streaming.ts"],"sourcesContent":["/**\n * Agent Type Definitions for VibeForge BDS\n *\n * Defines types for all agent workflows following the PAORT cycle.\n */\n\n// ═══════════════════════════════════════════════════════════════════════\n// PAORT Stage Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport enum PAORTStage {\n  PLAN = \"PLAN\",\n  ACT = \"ACT\",\n  OBSERVE = \"OBSERVE\",\n  REFLECT = \"REFLECT\",\n  TRANSITION = \"TRANSITION\",\n}\n\nexport interface StageInput {\n  stage: PAORTStage;\n  data: Record<string, unknown>;\n  previousStageOutput?: StageOutput;\n}\n\nexport interface StageOutput {\n  stage: PAORTStage;\n  data: Record<string, unknown>;\n  summary: string;\n  status: \"success\" | \"failure\" | \"partial\";\n  metrics?: StageMetrics;\n}\n\nexport interface StageMetrics {\n  tokensUsed: number;\n  cost: number;\n  latencyMs: number;\n  modelUsed: string;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Session Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport enum SessionStatus {\n  PENDING = \"PENDING\",\n  RUNNING = \"RUNNING\",\n  COMPLETED = \"COMPLETED\",\n  FAILED = \"FAILED\",\n  CANCELLED = \"CANCELLED\",\n}\n\nexport interface BaseSession {\n  id: string;\n  type: \"planning\" | \"execution\" | \"evaluation\" | \"coordination\";\n  status: SessionStatus;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  currentStage?: PAORTStage;\n  error?: string;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Planning Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface PlanningRequest {\n  title: string;\n  description: string;\n  context?: Record<string, unknown>;\n  requirements?: string[];\n  constraints?: string[];\n}\n\nexport interface PlanningSession extends BaseSession {\n  type: \"planning\";\n  request: PlanningRequest;\n  stages: PlanningStages;\n  deliverable?: PlanningDeliverable;\n}\n\nexport interface PlanningStages {\n  plan?: StageOutput;\n  act?: StageOutput;\n  observe?: StageOutput;\n  reflect?: StageOutput;\n}\n\nexport interface PlanningDeliverable {\n  plan: {\n    title: string;\n    overview: string;\n    steps: PlanStep[];\n    estimatedEffort: string;\n    risks: string[];\n  };\n  prompt: string;\n  metadata: {\n    totalTokens: number;\n    totalCost: number;\n    duration: number;\n  };\n}\n\nexport interface PlanStep {\n  id: string;\n  title: string;\n  description: string;\n  dependencies: string[];\n  estimatedEffort: string;\n  acceptanceCriteria: string[];\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Execution Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface ExecutionRequest {\n  planSessionId: string;\n  plan: PlanningDeliverable;\n  options?: ExecutionOptions;\n  language?: string;\n  framework?: string;\n}\n\nexport interface ExecutionOptions {\n  runTests: boolean;\n  generateDocs: boolean;\n  autoCommit: boolean;\n}\n\nexport interface ExecutionSession extends BaseSession {\n  type: \"execution\";\n  request: ExecutionRequest;\n  stages: ExecutionStages;\n  result?: ExecutionResult;\n}\n\nexport interface ExecutionStages {\n  plan?: StageOutput;\n  act?: StageOutput;\n  observe?: StageOutput;\n  reflect?: StageOutput;\n}\n\nexport interface ExecutionResult {\n  code: {\n    filesModified: FileModification[];\n    filesCreated: FileCreation[];\n    filesDeleted: string[];\n  };\n  tests: TestResults;\n  metrics: ExecutionMetrics;\n  rollbackPoint?: string;\n  // Alternative property names used in templates\n  testResults?: TestResults;\n  filesModified?: FileModification[];\n}\n\nexport interface FileModification {\n  path: string;\n  additions: number;\n  deletions: number;\n  diff: string;\n  // Additional properties used in templates\n  type?: \"added\" | \"modified\" | \"deleted\" | \"renamed\";\n  oldPath?: string;\n  description?: string;\n}\n\nexport interface FileCreation {\n  path: string;\n  content: string;\n  lines: number;\n}\n\nexport interface TestResults {\n  passed: number;\n  failed: number;\n  skipped: number;\n  total: number;\n  coverage?: {\n    lines: number;\n    functions: number;\n    branches: number;\n    statements: number;\n  };\n  failures: TestFailure[];\n}\n\nexport interface TestFailure {\n  testName: string;\n  filePath: string;\n  error: string;\n  stack?: string;\n}\n\nexport interface ExecutionMetrics {\n  tokensUsed: number;\n  cost: number;\n  duration: number;\n  modelUsed: string;\n  linesOfCode: number;\n  // Additional metrics used in templates\n  testsRun?: number;\n  testsPassed?: number;\n  testsFailed?: number;\n  filesModified?: number;\n  linesAdded?: number;\n  linesRemoved?: number;\n  startTime?: string;\n  endTime?: string;\n  provider?: string;\n  outputTokens?: number;\n  inputTokens?: number;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Evaluator Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface EvaluationRequest {\n  executionSessionId?: string;\n  result?: ExecutionResult;\n  criteria?: EvaluationCriteria | string[];\n  // Alternative property name\n  executionResult?: ExecutionResult;\n}\n\nexport interface EvaluationCriteria {\n  checkSASCompliance: boolean;\n  checkTestCoverage: boolean;\n  checkCodeQuality: boolean;\n  checkPerformance: boolean;\n}\n\nexport interface EvaluationSession extends BaseSession {\n  type: \"evaluation\";\n  request: EvaluationRequest;\n  stages: EvaluationStages;\n  assessment?: EvaluationAssessment;\n}\n\nexport interface EvaluationStages {\n  plan?: StageOutput;\n  act?: StageOutput;\n  observe?: StageOutput;\n  reflect?: StageOutput;\n}\n\nexport interface EvaluationAssessment {\n  qualityScore: number; // 0-100\n  sasCompliance: SASCompliance;\n  codeReview: CodeReview;\n  improvements: Improvement[];\n  metrics: EvaluationMetrics;\n  // Snake_case variants for API compatibility\n  quality_metrics: QualityMetrics;\n  code_review: CodeReview;\n  sas_compliance: SASCompliance;\n}\n\nexport interface QualityMetrics {\n  overall: number;\n  code_quality: number;\n  performance: number;\n  security: number;\n  maintainability: number;\n  test_coverage?: number;\n  complexity?: number | \"low\" | \"medium\" | \"high\";\n}\n\nexport interface SASViolation {\n  rule: string;\n  severity: \"error\" | \"warning\" | \"info\";\n  filePath: string;\n  lineNumber?: number;\n  description: string;\n  suggestion: string;\n}\n\nexport interface SASCompliance {\n  compliant: boolean;\n  violations: SASViolation[];\n  passedChecks: string[];\n  failedChecks: string[];\n  // Additional SAS compliance metrics\n  file_structure?: ComplianceCategory;\n  overall_score?: number;\n  naming_conventions?: NamingConvention[] | ComplianceCategory;\n  code_standards?: CodeStandard[] | ComplianceCategory;\n  architecture_patterns?: ArchitecturePattern[] | ComplianceCategory;\n}\n\nexport interface ComplianceCategory {\n  score: number;\n  passed: boolean;\n  issues: string[];\n  // Additional properties used in templates\n  compliant?: boolean;\n  suggestions?: string[];\n}\n\n// Pattern item for architecture_patterns array\nexport interface ArchitecturePattern {\n  pattern: string;\n  compliant: boolean;\n  notes?: string;\n}\n\n// Convention item for naming_conventions array\nexport interface NamingConvention {\n  category: string;\n  score: number;\n  compliant: boolean;\n  violations?: string[];\n}\n\n// Standard item for code_standards array\nexport interface CodeStandard {\n  standard: string;\n  compliant: boolean;\n}\n\nexport interface CodeReview {\n  findings: CodeFinding[];\n  summary: string;\n  overallRating: number; // 0-10\n  // Allow accessing length for API compatibility\n  length?: number;\n}\n\n// Alias for component compatibility\nexport type CodeReviewItem = CodeFinding;\n\nexport interface CodeFinding {\n  id: string;\n  type: \"bug\" | \"smell\" | \"security\" | \"performance\" | \"style\";\n  severity: \"critical\" | \"high\" | \"medium\" | \"low\";\n  filePath: string;\n  lineNumber?: number;\n  description: string;\n  suggestion: string;\n  codeSnippet?: string;\n  // Additional properties used in templates\n  file?: string;\n  line?: number;\n  code?: string;\n  category?: string;\n  message?: string;\n}\n\nexport interface Improvement {\n  id: string;\n  priority: \"critical\" | \"high\" | \"medium\" | \"low\";\n  category: string;\n  description: string;\n  before: string;\n  after: string;\n  impact: string;\n  effort: string;\n  // Additional properties used in templates\n  current_code?: string;\n  suggested_code?: string;\n  rationale?: string;\n  title?: string;\n}\n\nexport interface EvaluationMetrics {\n  tokensUsed: number;\n  cost: number;\n  duration: number;\n  modelUsed: string;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Coordinator Agent Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface WorkflowRequest {\n  task?: string;\n  agents: AgentNode[];\n  dependencies: Dependency[];\n  options?: Record<string, unknown>;\n  title?: string;\n  description?: string;\n}\n\nexport interface AgentNode {\n  id: string;\n  type: \"planning\" | \"execution\" | \"evaluation\" | string;\n  config?: Record<string, unknown>;\n  position?: { x: number; y: number };\n  status?: string;\n}\n\nexport interface Dependency {\n  from: string; // Agent node ID\n  to: string; // Agent node ID\n  dataMapping?: Record<string, string>;\n}\n\nexport interface CoordinationSession extends BaseSession {\n  type: \"coordination\";\n  request: WorkflowRequest;\n  workflow: WorkflowExecution;\n}\n\nexport interface WorkflowExecution {\n  nodes: WorkflowNodeExecution[];\n  status: WorkflowStatus;\n  startedAt?: Date;\n  completedAt?: Date;\n  error?: string;\n  // Snake_case variants for API compatibility\n  agent_states?: AgentState[];\n  current_agent?: string;\n}\n\nexport interface AgentState {\n  id: string;\n  type: string;\n  status: string;\n  progress?: number;\n  output?: string;\n  agent_id?: string;\n}\n\nexport interface WorkflowNodeExecution {\n  nodeId: string;\n  sessionId?: string;\n  status: \"pending\" | \"running\" | \"completed\" | \"failed\";\n  startedAt?: Date;\n  completedAt?: Date;\n  error?: string;\n  progress?: number; // 0-100\n}\n\nexport enum WorkflowStatus {\n  PENDING = \"PENDING\",\n  RUNNING = \"RUNNING\",\n  COMPLETED = \"COMPLETED\",\n  FAILED = \"FAILED\",\n  PARTIAL = \"PARTIAL\",\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Streaming Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface StreamChunk {\n  type: \"chunk\" | \"stage_start\" | \"stage_end\" | \"complete\" | \"error\";\n  data: unknown;\n  timestamp: Date;\n}\n\nexport interface StageStreamChunk extends StreamChunk {\n  type: \"chunk\";\n  data: {\n    stage: PAORTStage;\n    content: string;\n  };\n}\n\nexport interface StageStartChunk extends StreamChunk {\n  type: \"stage_start\";\n  data: {\n    stage: PAORTStage;\n  };\n}\n\nexport interface StageEndChunk extends StreamChunk {\n  type: \"stage_end\";\n  data: {\n    stage: PAORTStage;\n    output: StageOutput;\n  };\n}\n\nexport interface CompleteChunk extends StreamChunk {\n  type: \"complete\";\n  data: {\n    sessionId: string;\n    result: unknown;\n  };\n}\n\nexport interface ErrorChunk extends StreamChunk {\n  type: \"error\";\n  data: {\n    error: string;\n    stage?: PAORTStage;\n  };\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Union Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport type AgentSession =\n  | PlanningSession\n  | ExecutionSession\n  | EvaluationSession\n  | CoordinationSession;\n\nexport type AgentRequest =\n  | PlanningRequest\n  | ExecutionRequest\n  | EvaluationRequest\n  | WorkflowRequest;\n\nexport type AgentResult =\n  | PlanningDeliverable\n  | ExecutionResult\n  | EvaluationAssessment\n  | WorkflowExecution;\n\n// ═══════════════════════════════════════════════════════════════════════\n// Type Aliases for backwards compatibility\n// ═══════════════════════════════════════════════════════════════════════\n\nexport type DependencyEdge = Dependency;\nexport type ImprovementSuggestion = Improvement;\nexport type SasCompliance = SASCompliance;\nexport type FileChange = FileModification;\n","/**\n * SSE Streaming Service\n *\n * Handles Server-Sent Events (SSE) streaming for real-time agent output.\n */\n\nimport type { StreamChunk } from '$lib/types/agents';\nimport { classifyError, createNetworkError, type AppError } from '$lib/utils/errors';\n\n// ═══════════════════════════════════════════════════════════════════════\n// Types\n// ═══════════════════════════════════════════════════════════════════════\n\nexport interface StreamOptions {\n\tonChunk?: (chunk: string) => void;\n\tonStageStart?: (stage: string) => void;\n\tonStageEnd?: (stage: string, output: unknown) => void;\n\tonComplete?: (result: unknown) => void;\n\tonError?: (error: AppError) => void;\n\treconnect?: boolean;\n\treconnectDelay?: number;\n\tmaxReconnectAttempts?: number;\n}\n\nexport interface StreamSubscription {\n\tclose: () => void;\n\tpause: () => void;\n\tresume: () => void;\n\treadonly isActive: boolean;\n\treadonly isPaused: boolean;\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Streaming Service\n// ═══════════════════════════════════════════════════════════════════════\n\nclass StreamingService {\n\tprivate activeStreams: Map<string, EventSource> = new Map();\n\n\t/**\n\t * Subscribe to an SSE stream\n\t */\n\tsubscribe(\n\t\turl: string,\n\t\toptions: StreamOptions = {}\n\t): StreamSubscription {\n\t\tconst {\n\t\t\tonChunk,\n\t\t\tonStageStart,\n\t\t\tonStageEnd,\n\t\t\tonComplete,\n\t\t\tonError,\n\t\t\treconnect = true,\n\t\t\treconnectDelay = 3000,\n\t\t\tmaxReconnectAttempts = 5\n\t\t} = options;\n\n\t\tlet eventSource: EventSource | null = null;\n\t\tlet reconnectAttempts = 0;\n\t\tlet isPaused = false;\n\t\tlet isClosed = false;\n\t\tlet reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n\n\t\tconst connect = () => {\n\t\t\tif (isClosed) return;\n\n\t\t\ttry {\n\t\t\t\teventSource = new EventSource(url);\n\t\t\t\tthis.activeStreams.set(url, eventSource);\n\n\t\t\t\t// Handle chunk messages\n\t\t\t\teventSource.addEventListener('chunk', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'chunk' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst chunkData = chunk.data as { content?: string };\n\t\t\t\t\t\t\tif (chunkData.content && onChunk) {\n\t\t\t\t\t\t\t\tonChunk(chunkData.content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse chunk:', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle stage start\n\t\t\t\teventSource.addEventListener('stage_start', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'stage_start' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst stageData = chunk.data as { stage?: string };\n\t\t\t\t\t\t\tif (stageData.stage && onStageStart) {\n\t\t\t\t\t\t\t\tonStageStart(stageData.stage);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse stage_start:', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle stage end\n\t\t\t\teventSource.addEventListener('stage_end', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'stage_end' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst stageData = chunk.data as { stage?: string; output?: unknown };\n\t\t\t\t\t\t\tif (stageData.stage && onStageEnd) {\n\t\t\t\t\t\t\t\tonStageEnd(stageData.stage, stageData.output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse stage_end:', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle completion\n\t\t\t\teventSource.addEventListener('complete', (event: MessageEvent) => {\n\t\t\t\t\tif (isPaused || isClosed) return;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst chunk: StreamChunk = JSON.parse(event.data);\n\t\t\t\t\t\tif (chunk.type === 'complete' && typeof chunk.data === 'object' && chunk.data !== null) {\n\t\t\t\t\t\t\tconst completeData = chunk.data as { result?: unknown };\n\t\t\t\t\t\t\tif (onComplete) {\n\t\t\t\t\t\t\t\tonComplete(completeData.result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('[StreamingService] Failed to parse complete:', err);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcloseStream();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Handle errors from stream\n\t\t\t\teventSource.addEventListener('error', () => {\n\t\t\t\t\tif (isClosed) return;\n\n\t\t\t\t\tconst error = createNetworkError('Stream connection error');\n\n\t\t\t\t\t// Attempt reconnection\n\t\t\t\t\tif (reconnect && reconnectAttempts < maxReconnectAttempts) {\n\t\t\t\t\t\treconnectAttempts++;\n\t\t\t\t\t\tconsole.log(`[StreamingService] Reconnecting (attempt ${reconnectAttempts}/${maxReconnectAttempts})...`);\n\n\t\t\t\t\t\teventSource?.close();\n\t\t\t\t\t\tthis.activeStreams.delete(url);\n\n\t\t\t\t\t\treconnectTimer = setTimeout(() => {\n\t\t\t\t\t\t\tconnect();\n\t\t\t\t\t\t}, reconnectDelay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (onError) {\n\t\t\t\t\t\t\tonError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcloseStream();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reset reconnect attempts on successful connection\n\t\t\t\teventSource.addEventListener('open', () => {\n\t\t\t\t\treconnectAttempts = 0;\n\t\t\t\t\tconsole.log('[StreamingService] Stream connected');\n\t\t\t\t});\n\n\t\t\t} catch (err) {\n\t\t\t\tconst error = classifyError(err);\n\t\t\t\tif (onError) {\n\t\t\t\t\tonError(error);\n\t\t\t\t}\n\t\t\t\tcloseStream();\n\t\t\t}\n\t\t};\n\n\t\tconst closeStream = () => {\n\t\t\tisClosed = true;\n\t\t\tisPaused = false;\n\n\t\t\tif (reconnectTimer) {\n\t\t\t\tclearTimeout(reconnectTimer);\n\t\t\t\treconnectTimer = null;\n\t\t\t}\n\n\t\t\tif (eventSource) {\n\t\t\t\teventSource.close();\n\t\t\t\tthis.activeStreams.delete(url);\n\t\t\t\teventSource = null;\n\t\t\t}\n\t\t};\n\n\t\tconst pauseStream = () => {\n\t\t\tisPaused = true;\n\t\t};\n\n\t\tconst resumeStream = () => {\n\t\t\tisPaused = false;\n\t\t};\n\n\t\t// Start the connection\n\t\tconnect();\n\n\t\t// Return subscription interface\n\t\treturn {\n\t\t\tclose: closeStream,\n\t\t\tpause: pauseStream,\n\t\t\tresume: resumeStream,\n\t\t\tget isActive() {\n\t\t\t\treturn !isClosed && eventSource !== null;\n\t\t\t},\n\t\t\tget isPaused() {\n\t\t\t\treturn isPaused;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Close all active streams\n\t */\n\tcloseAll(): void {\n\t\tthis.activeStreams.forEach((eventSource) => {\n\t\t\teventSource.close();\n\t\t});\n\t\tthis.activeStreams.clear();\n\t}\n\n\t/**\n\t * Get count of active streams\n\t */\n\tget activeStreamCount(): number {\n\t\treturn this.activeStreams.size;\n\t}\n}\n\n// ═══════════════════════════════════════════════════════════════════════\n// Export Singleton\n// ═══════════════════════════════════════════════════════════════════════\n\nexport const streamingService = new StreamingService();\n"],"names":["PAORTStage","SessionStatus","WorkflowStatus","streamingService","activeStreams","Map","subscribe","url","options","onChunk","onStageStart","onStageEnd","onComplete","onError","reconnect","reconnectDelay","maxReconnectAttempts","eventSource","reconnectAttempts","isPaused","isClosed","reconnectTimer","connect","EventSource","this","set","addEventListener","event","chunk","JSON","parse","data","type","chunkData","content","err","stageData","stage","output","completeData","result","closeStream","error","createNetworkError","close","delete","setTimeout","classifyError","clearTimeout","pause","resume","isActive","closeAll","forEach","clear","activeStreamCount","size"],"mappings":"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"}